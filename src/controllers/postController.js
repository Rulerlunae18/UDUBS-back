const prisma = require('../utils/prisma');
const { publicUrl } = require('../services/storage');

// === helpers for dynamic bio from GameProfile ===
function formatPlaytime(seconds) {
  const totalMinutes = Math.floor((seconds || 0) / 60);
  if (totalMinutes <= 0) return '–º–µ–Ω—å—à–µ —á–∞—Å–∞ –≤ —Å–∏—Å—Ç–µ–º–µ';

  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;

  if (hours && minutes) return `${hours} —á ${minutes} –º–∏–Ω –≤ —Å–∏—Å—Ç–µ–º–µ`;
  if (hours) return `${hours} —á –≤ —Å–∏—Å—Ç–µ–º–µ`;
  return `${minutes} –º–∏–Ω –≤ —Å–∏—Å—Ç–µ–º–µ`;
}

function humanLang(code) {
  switch ((code || '').toLowerCase()) {
    case 'uk':
      return '—É–∫—Ä–∞–∏–Ω—Å–∫–∏–π';
    case 'ru':
      return '—Ä—É—Å—Å–∫–∏–π';
    case 'en':
      return '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π';
    case 'ja':
      return '—è–ø–æ–Ω—Å–∫–∏–π';
    case 'de':
      return '–Ω–µ–º–µ—Ü–∫–∏–π';
    default:
      return `—è–∑—ã–∫: ${code || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π'}`;
  }
}

function generateDynamicBio(stats) {
  if (!stats) {
    return 'Autogenerated field operator.';
  }

  // === –í–†–ï–ú–Ø –ò–ì–†–´ ===
  const play = formatPlaytime(stats.total_playtime || 0);

  // === –Ø–ó–´–ö –°–ò–°–¢–ï–ú–´ ===
  const lang = humanLang(stats.system_lang);

  // === –ú–ï–°–¢–û–ü–û–õ–û–ñ–ï–ù–ò–ï ===
  const country = stats.country || '–Ω–µ—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–π —Å—Ç—Ä–∞–Ω—ã';
  const city = stats.city ? `, ${stats.city}` : '';

  // === SAFE MODE ===
  const safe = stats.safe_mode
    ? 'SAFE-—Ä–µ–∂–∏–º –≤–∫–ª—é—á—ë–Ω.'
    : 'SAFE-—Ä–µ–∂–∏–º –æ—Ç–∫–ª—é—á—ë–Ω.';

  // === –î–†–£–ì–ò–ï –ú–ï–¢–†–ò–ö–ò ===
  const kassi = stats.kassi_named ? 'Kassi: —É—Å—Ç–∞–Ω–æ–≤–∏–ª–∞ –∫–æ–Ω—Ç–∞–∫—Ç.' : 'Kassi: –µ—â—ë –Ω–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞–ª–∞.';
  const scarlett = stats.scarlett_taunts > 0
    ? `Scarlett –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞–ª–∞ ${stats.scarlett_taunts} —Ä–∞–∑.`
    : 'Scarlett –ø–æ–∫–∞ –Ω–µ –ø—Ä–æ—è–≤–ª—è–ª–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏.';
  const silvair = stats.silvair_rickroll > 0
    ? `Silvair Rickroll: ${stats.silvair_rickroll} —Ä–∞–∑.`
    : 'Silvair –ø–æ–∫–∞ –Ω–µ –≤–º–µ—à–∏–≤–∞–ª—Å—è.';

  // === –§–ò–ù–ê–õ–¨–ù–û–ï BIO ===
  return `
–°—Ç–∞–∂ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞: ${play}.
–õ–æ–∫–∞—Ü–∏—è: ${country}${city}.
–°–∏—Å—Ç–µ–º–Ω—ã–π —è–∑—ã–∫: ${lang}.
${safe}
  `.trim();
}


/* === –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ—Å—Ç–æ–≤ === */
async function listPosts(_req, res) {
  try {
    const posts = await prisma.post.findMany({
      orderBy: { createdAt: 'desc' },
      include: {
        images: true,
        fakeAuthor: true, // üëà —Å–≤—è–∑—å —Å FakeUser
      },
    });

    const withViews = await Promise.all(
      posts.map(async (p) => {
        const v = await prisma.view.count({ where: { postId: p.id } });
        return {
          ...p,
          viewsCount: v,
          author: p.fakeAuthor || null, // üëà –¥–æ–±–∞–≤–ª—è–µ–º –ø—Å–µ–≤–¥–æ–Ω–∏–º
        };
      })
    );

    res.json(withViews);
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ—Å—Ç–æ–≤:', err);
    res.status(500).json({ error: 'Server error while listing posts' });
  }
}

async function getPost(req, res) {
  try {
    const id = Number(req.params.id);
    if (!id || isNaN(id)) {
      return res.status(400).json({ error: 'Invalid post ID' });
    }

    const session = req.session?.user || null;

    const loggedUserId = session?.id || null;          
    const realUserId   = session?.realUser?.id || null; 
    const role         = session?.role || null;

    // –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–æ—Å—Ç
    let post = await prisma.post.findUnique({
      where: { id },
      include: {
        images: true,
        fakeAuthor: true,
      },
    });

    if (!post) return res.status(404).json({ error: 'Post not found' });

    // —Å—á–∏—Ç–∞–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä—ã
    const viewsCount = await prisma.view.count({ where: { postId: id } });

    // === üü• –ê–¥–º–∏–Ω ‚Äî –±–µ–∑ –ø–æ–¥–º–µ–Ω—ã ===
    if (role === 'ADMIN') {
      return res.json({
        ...post,
        author: post.fakeAuthor,
        viewsCount,
      });
    }

    // === üü¶ –°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–ª–æ—Ç –∏–≥—Ä–æ–∫–∞ ‚Äî –ø–æ–¥–º–µ–Ω–∞ –∞–≤—Ç–æ—Ä–∞ ===
    if (post.fakeAuthor?.userId === loggedUserId) {

      // –ó–∞–≥—Ä—É–∂–∞–µ–º RealUser
      const ru = await prisma.realUser.findUnique({
        where: { id: realUserId }
      });

      if (ru) {
        // ‚¨áÔ∏è –ó–∞–≥—Ä—É–∂–∞–µ–º –ü–û–°–õ–ï–î–ù–ò–ô GameProfile –¢–û–õ–¨–ö–û –ø–æ playerId (UUID)
        const stats = await prisma.gameProfile.findFirst({
          where: { playerId: ru.password },
          orderBy: { collected_at: 'desc' }
        });

        console.log("üî• –ü–û–°–õ–ï–î–ù–ò–ô STATS –î–õ–Ø –ü–û–°–¢–ê:", stats?.total_playtime);

        const substitutedAuthor = {
          ...post.fakeAuthor,
          codename: ru.username,
          avatarUrl: ru.avatarUrl || post.fakeAuthor.avatarUrl,
          rank: 'Operator',
          clearance: 'D-13',

          // ‚¨áÔ∏è –ü–µ—Ä–µ–¥–∞—ë–º –∏–º–µ–Ω–Ω–æ –ü–û–°–õ–ï–î–ù–ò–ï –°–¢–ê–¢–´
          bio: stats ? generateDynamicBio(stats) : "Autogenerated field operator."
        };

        return res.json({
          ...post,
          fakeAuthor: substitutedAuthor,
          author: substitutedAuthor,
          viewsCount,
        });
      }
    }

    // === –æ–±—ã—á–Ω—ã–π NPC / —á—É–∂–æ–π —Å–ª–æ—Ç ===
    return res.json({
      ...post,
      author: post.fakeAuthor,
      viewsCount,
    });

  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å—Ç–∞:', err);
    res.status(500).json({ error: 'Server error while fetching post' });
  }
}


/* === –ü–æ–ª—É—á–∏—Ç—å –∞—Ä—Ö–∏–≤ (–ø–æ—Å—Ç—ã —Å –æ–±–ª–æ–∂–∫–∞–º–∏) === */
async function listArchive(_req, res) {
  try {
    const posts = await prisma.post.findMany({
      where: { NOT: { coverImage: null } },
      orderBy: { createdAt: 'desc' },
      include: {
        fakeAuthor: true,
      },
    });

    res.json(
      posts.map((p) => ({
        ...p,
        author: p.fakeAuthor || null,
      }))
    );
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –∞—Ä—Ö–∏–≤–∞:', err);
    res.status(500).json({ error: 'Failed to fetch archive' });
  }
}

/* === –°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç === */
async function createPost(req, res) {
  try {
    const {
      title,
      body,
      coverCaption,
      stamp,
      clearance,
      fakeAuthorId, // üëà –ø—Ä–∏—Ö–æ–¥–∏—Ç —Å —Ñ—Ä–æ–Ω—Ç–∞
    } = req.body;

    if (!title || !body) {
      return res.status(400).json({ error: 'title and body are required' });
    }

    let coverImage = null;
    if (req.file) {
      coverImage = publicUrl(req.file.path);
    }

    let fileType = null;
      if (req.file) {
        fileType = req.file.mimetype || null; // –Ω–∞–ø—Ä–∏–º–µ—Ä "image/png" –∏–ª–∏ "application/pdf"
      }

    const created = await prisma.post.create({
      data: {
        title,
        body,
        coverImage,
        coverCaption: coverCaption || null,
        stamp: stamp || null,
        clearance: clearance || null,
        fakeAuthorId: fakeAuthorId ? Number(fakeAuthorId) : null, 
        fileType,// ‚úÖ –∫–ª—é—á–µ–≤–æ–µ
      },
      include: { fakeAuthor: true },
    });

    // üëá –¥–æ–±–∞–≤–ª—è–µ–º –ø—Å–µ–≤–¥–æ–Ω–∏–º author
    res.status(201).json({ ...created, author: created.fakeAuthor || null });
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ—Å—Ç–∞:', err);
    res.status(500).json({ error: 'Failed to create post' });
  }
}

/* === –û–±–Ω–æ–≤–∏—Ç—å –ø–æ—Å—Ç === */
async function updatePost(req, res) {
  try {
    const id = Number(req.params.id);
    const {
      title,
      body,
      coverCaption,
      stamp,
      clearance,
      fakeAuthorId,
    } = req.body;

    const exists = await prisma.post.findUnique({ where: { id } });
    if (!exists) return res.status(404).json({ error: 'Post not found' });

    let coverImage = exists.coverImage;
    if (req.files?.cover?.[0]) {
      coverImage = publicUrl(req.files.cover[0].path);
    }

    const updated = await prisma.post.update({
      where: { id },
      data: {
        title,
        body,
        coverImage,
        coverCaption: coverCaption || exists.coverCaption,
        stamp: stamp || exists.stamp,
        clearance: clearance || exists.clearance,
        fakeAuthorId: fakeAuthorId
          ? Number(fakeAuthorId)
          : exists.fakeAuthorId,
      },
      include: { fakeAuthor: true },
    });

    // –û–±–Ω–æ–≤–ª—è–µ–º –≥–∞–ª–µ—Ä–µ—é, –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ —Ñ–∞–π–ª—ã
    if (req.files && req.files.images) {
      const imgs = req.files.images.map((f) => ({
        postId: updated.id,
        imageUrl: publicUrl(f.path),
        caption: null,
      }));
      if (imgs.length) await prisma.postImage.createMany({ data: imgs });
    }

    res.json({ ...updated, author: updated.fakeAuthor || null });
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ—Å—Ç–∞:', err);
    res.status(500).json({ error: 'Failed to update post' });
  }
}

/* === –£–¥–∞–ª–∏—Ç—å –ø–æ—Å—Ç === */
async function deletePost(req, res) {
  try {
    const id = Number(req.params.id);
    await prisma.post.delete({ where: { id } });
    res.json({ message: 'Deleted' });
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ—Å—Ç–∞:', err);
    res.status(500).json({ error: 'Failed to delete post' });
  }
}

/* === –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ—Å–º–æ—Ç—Ä –ø–æ—Å—Ç–∞ === */
async function addView(req, res) {
  try {
    const id = Number(req.params.id);
    const { sessionId } = req.body;

    if (!id || !sessionId) {
      return res.status(400).json({ error: 'Missing post id or sessionId' });
    }

    await prisma.view.create({
      data: { postId: id, sessionId },
    });

    res.json({ message: 'View recorded' });
  } catch (err) {
    console.error('Error recording view:', err);
    res.status(500).json({ error: 'Failed to record view' });
  }
}

module.exports = {
  listPosts,
  getPost,
  listArchive,
  addView,
  createPost,
  updatePost,
  deletePost,
};
